¿Cuál es la diferencia fundamental entre "pertenencia" y "localización"?;La **pertenencia** es la pregunta booleana de si un elemento está o no en un conjunto (un "sí" o "no").<br>La **localización** es el proceso de *encontrar* la posición de ese elemento en la memoria. La localización es un prerrequisito para poder afirmar la pertenencia.
¿Cuál es la única estrategia de búsqueda posible para una lista sin información adicional (no ordenada)?;La búsqueda secuencial: examinar cada celda una tras otra, desde el principio hasta el final.
Describe la estructura de una "Lista de alojamiento secuencial de largo conocido (sin orden)".;Es un conjunto de datos almacenado en un bloque de memoria contiguo (un vector), donde se conocen los índices exactos del primer y último elemento.<br><br>**Diagrama:**<br><pre>V:<br>  valor -> | 25 | 158 | 77 | ... | 258 |<br>índice ->   41   42    43   ...    49</pre>
¿Cuál es el pseudo-código para la búsqueda de pertenencia en un vector no ordenado de largo conocido (de índice `li` a `ls`)?;`function pertenece(x):<br>  i := li<br>  while (i <= ls) and (V[i] <> x) do<br>    i := i + 1<br>  return (i <= ls)`
¿Qué es una lista con "terminación dada por contenido" o centinela?;Es una lista secuencial donde no se conoce el largo de antemano. El final se indica mediante un valor especial (el centinela, ej: `*`) que no puede ser un dato válido del conjunto.<br><br>**Diagrama:**<br><pre>V:<br>  valor -> | 25 | 158 | ... | 258 |  *  |<br>índice ->   41   42    ...    49    50</pre>
¿Cuál es el pseudo-código para la búsqueda en una lista secuencial no ordenada con un centinela `*`?;`function pertenece(x):<br>  i := 41<br>  while (V[i] <> *) and (V[i] <> x) do<br>    i := i + 1<br>  return (V[i] <> *)`
Describe la estructura de una "Lista vinculada (o enlazada) sin orden".;Es un conjunto de datos almacenados en "nodos" dispersos en memoria. Cada nodo contiene el dato (`valor`) y un puntero (`siguiente`) a la dirección del próximo nodo. El último nodo apunta a `nil`.<br><br>**Diagrama:**<br><pre>  inicio<br>    |<br>    V<br>+----+----+   +-----+----+      +-----+-----+<br>| 25 |  •-|-->| 158 |  •-|-->...-->| 258 | nil |<br>+----+----+   +-----+----+      +-----+-----+</pre>
¿Cuál es el pseudo-código para la búsqueda de pertenencia en una lista vinculada no ordenada?;`function pertenece(x):<br>  p := inicio<br>  while (p <> nil) and (p↑.valor <> x) do<br>    p := p↑.siguiente<br>  return (p <> nil)`
¿Cuál es la optimización clave que se puede hacer en una búsqueda secuencial si la lista está ordenada?;Se puede detener la búsqueda prematuramente. Si se busca `x` y se encuentra un elemento `y > x`, se puede asegurar que `x` no está en el resto de la lista sin necesidad de recorrerla.
¿Cuál es el cambio principal en el pseudo-código de búsqueda secuencial para una lista **ordenada**?;La condición del bucle cambia de `V[i] <> x` a `V[i] < x`. Se avanza solo mientras los elementos sean menores que el buscado.<br><br>**Código del bucle:**<br>`while (i < 50) and (V[i] < x) do<br>  i := i + 1<br>return ((i < 50) and (V[i] = x))`
¿Qué es la búsqueda binaria (o trisección) y en qué tipo de estructura se aplica?;Es un algoritmo de búsqueda muy eficiente que se aplica sobre **listas secuenciales ordenadas**. Funciona comparando el elemento buscado con el elemento del medio de la lista, descartando la mitad de la lista en cada paso.
Describe el pseudo-código para la búsqueda binaria en un vector ordenado `V` con límites `li` y `ls`.;`function pertenece(x):<br>  // Inicialización fuera del bucle<br>  m := (li + ls) div 2<br>  // Bucle principal<br>  while (li <= ls) and (V[m] <> x) do<br>    if V[m] < x then<br>      li := m + 1<br>    else<br>      ls := m - 1<br>    m := (li + ls) div 2<br>  return (li <= ls)`
¿Qué es la distribución pseudo-aleatoria de datos o Hashing?;Es una técnica para almacenar y recuperar datos que intenta calcular la posición de un elemento `x` directamente a través de una **función hash** `h(x)`, en lugar de buscarlo comparando. Su objetivo es un acceso en tiempo promedio constante O(1).
¿Qué es una "colisión" en el contexto de Hashing?;Una colisión ocurre cuando dos claves distintas, `x1` y `x2`, producen el mismo resultado al aplicarles la función hash, es decir, `h(x1) = h(x2)`.
Describe la técnica de "Rebalse Separado" (Separate Chaining) para manejar colisiones.;La tabla hash es un vector de punteros. Cada posición `i` apunta al inicio de una **lista vinculada** que almacena todos los elementos `x` tales que `h(x) = i`.<br><br>**Diagrama:**<br><pre>Tabla T<br> [ 0 ]-->[ 25 | • ]-->[ 51 | nil ]<br> [ 1 ]--> nil<br> [ 2 ]-->[ 158| • ]-->[ 171| nil ]<br> ...</pre>
¿Cuál es el pseudo-código para la búsqueda con Hashing y Rebalse Separado?;`function pertenece(x):<br>  // 1. Calcular el inicio de la lista<br>  p := T[h(x)]<br>  // 2. Búsqueda secuencial en la lista vinculada<br>  while (p <> nil) and (p↑.valor <> x) do<br>    p := p↑.siguiente<br>  return (p <> nil)`
Describe la técnica de "Rebalse Abierto" (Open Addressing) para manejar colisiones.;Todos los elementos se almacenan en la misma tabla. Si al intentar insertar un elemento en la posición `h(x)` esta se encuentra ocupada, se busca la siguiente celda libre siguiendo una secuencia de sondeo (lineal, cuadrática, etc.).
¿Qué es el "Rebalse Abierto Lineal" y cuál es su fórmula de avance?;Es una técnica de sondeo donde, si la celda `i` está ocupada, se prueba la siguiente celda `i+1`. El espacio se considera circular.<br>La fórmula para la siguiente celda es: \( i_{nuevo} = (i_{actual} + 1) \pmod{M} \)
¿Cuál es el pseudo-código para la búsqueda con Hashing y Rebalse Abierto Lineal (centinela `*`)?;`function pertenece(x):<br>  i := h(x)<br>  while (T[i] <> *) and (T[i] <> x) do<br>    i := (i + 1) mod M<br>  return (T[i] <> *)`
¿Qué es el "Rebalse Abierto Cuadrático" y por qué se usa?;Es una técnica de sondeo donde los saltos para encontrar una celda libre aumentan cuadráticamente (1, 4, 9, ...). Se usa para mitigar el "clustering primario" que afecta al sondeo lineal.<br>La fórmula para la k-ésima celda a probar (empezando en `i`) es: \( i_k = (i + c_1 k + c_2 k^2) \pmod{M} \). Una forma simple es sumar k al índice en el paso k: `i := (i + k) mod M`.
¿Cuál es el pseudo-código para la búsqueda con Hashing y Rebalse Abierto Cuadrático?;`function pertenece(x):<br>  i := h(x)<br>  k := 1<br>  while (T[i] <> *) and (T[i] <> x) do<br>    i := (i + k) mod M<br>    k := k + 1<br>  return (T[i] <> *)`
¿Qué es un Árbol Binario Ordenado de Búsqueda (BST)?;Es una estructura de datos de nodos enlazados donde cada nodo tiene un valor, un puntero a un subárbol izquierdo y un puntero a un subárbol derecho. Cumple la propiedad de que para cualquier nodo, todos los valores a su izquierda son menores y todos los valores a su derecha son mayores.
Dibuja la estructura de un Árbol Binario Ordenado de Búsqueda (BST).;**Respuesta:**<br><pre>             raiz<br>               |<br>               V<br>              93<br>             /  \<br>           51    171<br>          /  \   /   \<br>        25  64 158   234</pre>
¿Cuál es el pseudo-código para la búsqueda de pertenencia en un Árbol Binario de Búsqueda (BST)?;`function pertenece(x):<br>  p := raíz<br>  while (p <> nil) and (p↑.valor <> x) do<br>    if p↑.valor < x then<br>      p := p↑.hd  // Ir a la derecha<br>    else<br>      p := p↑.hi  // Ir a la izquierda<br>  return (p <> nil)`
¿Es posible combinar diferentes estructuras de datos? Da un ejemplo.;Sí. Un ejemplo muy potente es combinar Hashing con Árboles de Búsqueda. En lugar de usar una lista enlazada para las colisiones (Rebalse Separado), cada posición de la tabla hash apunta a la raíz de un Árbol Binario de Búsqueda.<br><br>**Diagrama:**<br><pre>Tabla T<br> [ 0 ]--> (Raíz de un BST con 25, 51...)<br> [ 1 ]--> nil<br> [ 2 ]--> (Raíz de un BST con 158, 171...)</pre>
¿Qué es la búsqueda binaria?;Es un algoritmo eficiente para localizar un elemento dentro de una **lista ordenada** de elementos.
¿Cuál es el prerrequisito fundamental para poder aplicar un algoritmo de búsqueda binaria?;La lista o el conjunto de elementos debe estar **ordenado**.
¿Cuáles son las dos implementaciones o enfoques de la búsqueda binaria que se estudian en el material?;1. Trisección<br>2. Bisección
¿Cómo divide el conjunto de búsqueda el método de "Trisección"?;La trisección divide el conjunto en **tres partes**: los elementos a la izquierda del elemento medio, el propio elemento medio y los elementos a la derecha del elemento medio.
Describe visualmente la división que realiza la Trisección.;La Trisección elige un elemento `m` y divide conceptualmente el rango de búsqueda en tres segmentos.<br>\[ \begin{array}{c|c|c} \text{Parte Izquierda} & \text{Medio} & \text{Parte Derecha} \\ \hline V[li \dots m-1] & V[m] & V[m+1 \dots ls] \end{array} \]
¿Cuáles son las decisiones de implementación que se deben tomar y mantener constantes en la Trisección?;1. **Uso de los límites (li, ls):** ¿Son inclusivos o exclusivos?<br>2. **Manejo de listas pares:** ¿El segmento más grande (con un elemento más) queda a la izquierda o a la derecha?<br>3. **Fórmula del medio (m):** Se debe usar una única fórmula para calcular el punto medio.
Describe los 6 pasos del algoritmo de Trisección para localizar un elemento.;1. **Inicio:** Definir el rango de búsqueda inicial con los límites `li` y `ls` que abarcan toda la lista.<br>2. **(Decisión de diseño):** Decidir cómo manejar el segmento más grande si la lista es par.<br>3. **Cálculo del medio:** Calcular la posición del elemento medio `m` del rango actual.<br>4. **Comparación:** Comparar el valor buscado con el valor en la posición `m`.<br>5. **Reducción del rango:** Si no son iguales, se descarta la mitad izquierda o derecha, actualizando `li` o `ls` para definir el nuevo rango.<br>6. **Repetición:** Repetir los pasos 3-5 hasta que se encuentre el elemento o el rango de búsqueda quede vacío (`li > ls`).
Describe el paso a paso de una búsqueda por **Trisección** para localizar el elemento 40 en `[5, 8, 10, 14, 16, 18, 25, 40, 60]`.;**Buscando:** 40. **Decisiones:** Límites inclusivos, segmento más grande a derecha.<br><br>**Paso 1: Rango [0, 9]**<br>`li = 0`, `ls = 9` → `m = (0 + 9) div 2 = 4`<br>**Comparación:** `40 > V[4]` (40 > 16). Se descarta la mitad izquierda y el medio. Nuevo `li = m + 1 = 5`.<br><br>**Paso 2: Rango [5, 9]**<br>`li = 5`, `ls = 9` → `m = (5 + 9) div 2 = 7`<br>**Comparación:** `40 == V[7]` (40 == 40). **Éxito**. Elemento encontrado en la posición 7.
¿Cómo divide el conjunto de búsqueda el método de "Bisección"?;La bisección divide el conjunto en **dos partes** con la cantidad de elementos más parecida posible. La división se realiza en torno a una "frontera" conceptual.
Describe visualmente la división que realiza la Bisección.;La Bisección define una "frontera" y elige un "testigo", `t`, para la comparación. El rango se divide en dos mitades.<br>\[ \begin{array}{c|c} \text{Mitad Izquierda} & \text{Mitad Derecha (con Testigo)} \\ \hline V[li \dots t-1] & V[\mathbf{t} \dots ls] \end{array} \]
¿Cuáles son las decisiones de implementación que se deben tomar y mantener constantes en la Bisección?;1. **Uso de los límites (li, ls):** ¿Inclusivos o exclusivos?<br>2. **Manejo de listas impares:** ¿El segmento más grande queda a la izquierda o a la derecha?<br>3. **Posición del testigo (t):** ¿Se usa el elemento a la izquierda o a la derecha de la frontera como testigo para la comparación?
Describe los 8 pasos del algoritmo de Bisección para localizar un elemento.;1. **Inicio:** Definir el rango `li` y `ls`.<br>2-3. **(Decisiones):** Decidir manejo de segmento y posición del testigo.<br>4. **Cálculo del testigo:** Calcular la posición `t` del testigo en el rango actual.<br>5. **Comparación:** Comparar el valor buscado con el valor del testigo.<br>6. **Reducción del rango:** Actualizar `li` o `ls` para reducir el rango a la mitad izquierda o derecha.<br>7. **Repetición:** Repetir los pasos 4-6 hasta que el rango de búsqueda sea de tamaño uno (`li == ls`).<br>8. **Comparación final:** Comparar el valor buscado con el único elemento que queda en la lista.
Describe el paso a paso de una búsqueda por **Bisección** para localizar el elemento 40 en `[5, 8, 10, 14, 16, 18, 25, 40, 60]`.;**Buscando:** 40. **Decisiones:** Límites inclusivos, testigo a derecha, segmento más grande a izquierda.<br><br>**Paso 1: Rango [0, 9]**<br>`li = 0`, `ls = 9` → `t = 5`. **Comparación:** `40 > V[5]` (40 > 18). Nuevo `li = t = 5`.<br><br>**Paso 2: Rango [5, 9]**<br>`li = 5`, `ls = 9` → `t = 7`. **Comparación:** `40 > V[7]` (40 > 25). Nuevo `li = t = 7`.<br><br>**Paso 3: Rango [7, 9]**<br>`li = 7`, `ls = 9` → `t = 8`. **Comparación:** `40 < V[8]` (40 < 60). Nuevo `ls = t - 1 = 7`.<br><br>**Paso 4: Rango [7, 7]**<br>`li = 7`, `ls = 7`. El rango es de tamaño uno. El bucle termina.<br><br>**Comparación Final:** Se compara `40` con `V[7]`. `40 == 40`. **Éxito**.
¿Cuál es la diferencia fundamental en la **lógica del bucle** entre Trisección y Bisección?;En **Trisección**, el bucle busca activamente la igualdad (`V[m] == x`) y puede terminar prematuramente si la encuentra. Su condición de parada es `(li > ls) OR (V[m] == x)`.<br>En **Bisección**, el bucle **no** busca la igualdad, su único objetivo es reducir el rango a un solo elemento. Su condición de parada es `(li == ls)`. La comprobación de igualdad se hace **después** de que el bucle termina.
¿Cómo manejan la "terminación" de la búsqueda la Trisección y la Bisección?;La **Trisección** termina de dos formas: cuando el rango se vacía (fracaso) o cuando se encuentra una coincidencia exacta `V[m] == x` (éxito).<br>La **Bisección** siempre termina de la misma forma: cuando el rango se reduce a un solo elemento. Luego, una comparación final fuera del bucle determina si fue éxito o fracaso.